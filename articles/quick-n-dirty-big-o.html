<!DOCTYPE html>
<!-- Since I'm used to writing en-US, I'll probably make mistakes in this document. Oh well. -->
<html lang="en-GB">

<head>
	<!--
	This file is UTF-8 with BOM (Byte Order Mark) - If you're using a decent editor, you can also see this in the status bar (at the bottom of the window) - 
	This means that the meta tag with charset=utf8 isn't needed.
	You could also set Content-Type in the packet header (that's something you should set in your server software)
	You can use http://validator.w3.org/i18n-checker/ to see if your header encoding to UTF-8
	For more information: https://www.w3.org/International/questions/qa-html-encoding-declarations#nonutf8
	-->
	<!-- <meta charset="utf-8" /> -->
	<!-- The title of the tab -->
	<title>Thaumatorium</title>
	<!-- <base href="https://thaumatorium.com/" /> -->
	<base href="/" />
	<!-- This description should show up in Google results -->
	<meta name=description content="Where the Magic happens" />
	<!-- Theme color for Android/iOS -->
	<meta name=theme-color content=#800 />
	<!-- icon for Apple's hardware -->
	<link rel="apple-touch-icon" href="/images/icons-192.png">
	<!-- meta viewport is actually CSS hidden inside your HTML -->
	<!-- More information https://wiki.whatwg.org/wiki/MetaExtensions#viewport and https://drafts.csswg.org/css-device-adapt/#viewport-meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- manifest.json is currently only supported by Chromium based browsers, as per https://www.caniuse.com/#feat=web-app-manifest -->
	<link rel=manifest href=/manifest.json />
	<link rel=icon href=/images/favicon.svg />
	<link async rel=stylesheet href=/styles/layout.css />
	<link async rel=stylesheet href=/styles/header.css />
	<link async rel=stylesheet href=/styles/nav.css />
	<link async rel=stylesheet href=/styles/main.css />
	<link async rel=stylesheet href=/styles/footer.css />
</head>

<body>
	<header>
		<div id=banner-logo>
			<a href="/">
				<img loading=lazy height=111 width=111 src="/images/Thaumatorium.svg"
					alt="main logo consisting of a checkerboard pattern" />
			</a>
		</div>
		<div id=banner-text>
			<h1 class=title>The Thaumatorium:</h1>
			<div class=subtitle>Where the magic happens</div>
			<p><sub>Last updated: <time id=updated>2020-06-11</time></sub></p>
			<script>
				let updated = document.getElementById("updated");
				let date = new Date(document.lastModified);
				updated.innerHTML = date.toISOString().split("T")[0];
			</script>
		</div>
	</header>

	<nav>
		<!-- `this` refers to the anchor element. `hash` refers to the `#xxxx` of the `href` attribute -->
		<!-- You can't use `this.href`, because that returns the full URL and we only want the hash -->
		<a href>Frontpage</a>
		<a href=pages/articles.html>Articles</a>
		<a href=pages/projects.html>Projects</a>
		<a href=pages/experimentations.html>Experimentations</a>
		<a href=pages/todo.html>TODO</a>
		<a href=pages/code-of-conduct.html>Code of Conduct</a>
		<a href=pages/about.html>About</a>
	</nav>

	<main>
		<section>
			<hgroup>
				<h1>Quick ‚Äòn Dirty Big O</h1>
				<div class=article-meta>
					<div class=article-published>Published:<br><time datetime=2019-03-16>2019-03-16</time></div>
					<div class=article-author>Author:<br>NostraDavid</div>
				</div>
			</hgroup>
			<h2>Disclaimer:</h2>
			<p>I'm not a mathematician, so it's not going to be exact, but I'll try to give you an intuitive understanding of
				Big
				O</p>
			Big O (usually written as <code>O(x)</code>, where x is a mathematical equation like <code>1</code>,
			<code>n</code>,
			<code>n^2</code> or <code>2^n</code>, for example) is a mathematical expression which expresses <em>how many steps
				an
				algorithm <strong>maximally</strong> will take to run.</em>

			<h2>Example 1:</h2>
			<p>If you have an array/list and want to lookup the nth item, it'll maximally take a so-called "constant time",
				expressed as <code>O(1)</code>. This does not mean it literally takes 1 step, but it means that no matter how
				many
				items you have in your data structure, the amount of steps it takes to retrieve the nth item is always a
				constant
				amount (whether it's actually 1 step or 10).</p>

			<h2>Example 2:</h2>
			<p>A lookup for a Tree structure takes up <code>O(log n)</code> steps, because you can (assuming the tree is
				sorted)
				eliminate the
				other branch every time you go left or right in the tree (see image below ‚Äì If you choose 9, instead of 3, you
				won't
				need to check the 1 and 4)</p>

			<figure>
				<img loading=lazy width=420 height=264 src=/images/binary-trees.png>
				<figcaption>Image nicked from <a
						href=http://cslibrary.stanford.edu/110/BinaryTrees.html>http://cslibrary.stanford.edu/110/BinaryTrees.html</a>
				</figcaption>
			</figure>
			<p>Note that you may execute a few constant steps before that (like creating a variable to save the answer in, so
				you
				can return that), but since <code>O(log n)</code>'s runtime overshadows that of any <code>O(1)</code> code, we
				only
				note the <code>O(log n)</code> part</p>

			<h2>Example 3:</h2>
			<p>If you want to find whether your array/list contains an a certain item (assuming it's an unsorted list ‚Äì a
				"does
				list contain x" check, if you will), it'll take <code>O(n)</code> steps, because every item has to be checked
				once
				to see if
				that's the item you're looking for.</p>

			<p>If you have a list with n=10 (meaning 10 items in your list) and the last item is the one you're looking for,
				it'll
				take 10 steps, but this is not necessarily so, as I've said in the beginning: Big O is <em>how many steps an
					algorithm <strong>maximally</strong> will take to run.</em></p>

			Again, if your algorithm has a part that happens to be <code>O(1)</code> or <code>O(log n)</code> (just as an
			example), you still note it down as <code>O(n)</code>, because <code>O(n)</code> overshadows the runtime of
			<code>O(1)</code> and <code>O(log n)</code>. Say you do, for some unknown reason, want to jot
			down the exact Big O, you'd write it down as <code>O(log n + n)</code>, but that's not what you'll see in
			practice.
			You can see
			what I mean, visually speaking, under the "Visually speaking" paragraph. :^)

			<h2>Most of the Big O notations:</h2>
			<p>I think you're getting the gist now, so I've copied a small, <em>simplified</em>, list of possible Big O
				expressions from Wikipedia. It's sorted from shortest runtime to longest. The italic rows are the ones I've seen
				most common.</p>

			<p>n is the amount of items that's fed to the algorithm, c is a constant number for that specific algorithm
				(usually
				it's either 2 or 3, though I don't guarantee it)</p>
			<table>
				<thead>
					<th>Notation</th>
					<th>Name</th>
				</thead>
				<tbody>
					<tr>
						<td><code>O(1)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Constant_time>constant</a> ‚Äì Think a C array lookup, like list[2]
						</td>
					</tr>
					<tr>
						<td><code>O(log‚Å° log‚Å° n)</code></td>
						<td>double logarithmic</td>
					</tr>
					<tr>
						<td><code>O(log ‚Å°n)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Logarithmic_time>logarithmic</a> ‚Äì Think a lookup in a sorted,
							binary,
							tree</td>
					</tr>
					<tr>
						<td><code>O((log‚Å° n)^c)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Polylogarithmic_time>polylogarithmic</a></td>
					</tr>
					<tr>
						<td><code>O(n^c)</code></td>
						<td>fractional power</td>
					</tr>
					<tr>
						<td><code>O(n)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Linear_time>linear</a> ‚Äì Think ‚Äòfor‚Äô loops</td>
					</tr>
					<tr>
						<td><code>O(n log ‚Å°n) = O(log ‚Å°n!)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Linearithmic_time>linearithmic</a>, loglinear, or quasilinear</td>
					</tr>
					<tr>
						<td><code>O(n^2)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Quadratic_time>quadratic</a> ‚Äì Think ‚Äòdouble for‚Äô loop</td>
					</tr>
					<tr>
						<td><code>O(n^c)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Polynomial_time>polynomial</a> or algebraic</td>
					</tr>
					<tr>
						<td><code>O(c^n)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Exponential_time>exponential</a></td>
					</tr>
					<tr>
						<td><code>O(n!)</code></td>
						<td><a href=https://en.wikipedia.org/wiki/Factorial>factorial</a></td>
					</tr>
				</tbody>
			</table>

			<p>For the full table: https://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions</p>
			<p>Another great wiki article is https://en.wikipedia.org/wiki/Time_complexity</p>

			<h2>Visually speaking:</h2>
			<p>Anything after <code>O(n)</code> should be tried to be avoided (though some algorithms, like turning two lists
				into Cartesian
				product/table, or perhaps a naive implementation of generating Fibonacci number for example) are currently not
				faster than say <code>2^n</code> (though there are faster implementations known for the Fibonacci number
				generator), which
				means you can‚Äôt always avoid it. As far as I know, we don‚Äôt mathematically know if it‚Äôs provable to find a
				faster
				algorithm for current algorithms.</p>

			<p>You can see why you should avoid anything >O(n) here:</p>
			<figure>
				<img loading=lazy height=974 width=942 src=/images/big-o.png>
				<figcaption>Source:
					https://en.wikipedia.org/wiki/Time_complexity#/media/File:Comparison_computational_complexity.svg</figcaption>
			</figure>

			<h2>A bit of trivia:</h2>
			<p>There‚Äôs a thing called P=NP, which states ‚ÄúIt asks whether every problem whose solution can be quickly verified
				can also be solved quickly‚Äù. In concrete form: A Sudoku puzzle can be verified to be correct in a relatively
				short
				time, yet not solved in a relatively short time. P basically means ‚Äúpolynomial‚Äù and NP ‚Äúexponential‚Äù or even
				‚Äúfactorial‚Äù. Do note that this is not mathematically correct, but I‚Äôm not also going into what the hell
				‚Äúnondeterministic polynomial time‚Äù is. That‚Äôs a bit out of the scope of this tutorial.</p>

			<p>Anyway, this P=NP think is currently still a mathematically unsolved problem within Computer Science, so maybe
				(if you‚Äôre smarter than me) you can possibly solve this in the future.</p>

			<h2>Closing words</h2>
			<p>I hope this short intro into Big O has been (at least a little bit) of help to you üôÇ</p>
			<p>PS: Note that there are other so called asymptotic notations (of which Big O is one), like o (little-o), Œ©
				(Big-Omega), œâ(little-omega, and Œò (theta). I have to confess that I have no idea what those represent, but I‚Äôm
				guessing things like average runtime and minimal runtime or something like that, but those mathematicians have
				to
				fuck everything up for me by using words I don‚Äôt understand ;_;</p>
			<p>Fucking mathematics, how does it work?</p>
		</section>
	</main>
	<footer>
		<div class="copyright">
			&copy;<a href="https://www.youtube.com/watch?v=czgOWmtGVGs" style="text-decoration: none; color: #800;">12019</a>
			&ndash; <a id=target-year href="http://updateyourfooter.com/" style="text-decoration: none; color: #800;"></a>,
			<abbr
				title="Copyright is implicit, almost anywhere in the world! If you want to know more, wikipedia 'Berne Convention'"
				style="text-decoration: none; color: #800;">Thaumatorium</abbr>

		</div>
		<!-- Sssh - don't tell anyone! -->
		<a class="secret" onclick=specialGoto(event)
			style="text-decoration: none; color:#800; cursor: default;font-family: sans-serif; font-size: small;">&#960;</a>
	</footer>
	<script async src=pwa.js></script>
	<script>
		let ty = document.getElementById("target-year");
		ty.innerHTML = new Date().getFullYear() + 10000;

		const specialGoto = (event) => {
			if (event.ctrlKey && event.shiftKey) {
				window.location.href = "/pages/praetorianpi.html";
			}
		}
	</script>
</body>

</html>